//book_management function file
/************************************************************************
University of Leeds
School of Computing
COMP1921 - Programming Project
Coursework 1

I confirm that the following code has been developed and written by me and it is entirely the result of my own work.
I also confirm that I have not copied any parts of this program from another person or any other source or facilitated someone to copy this program from me.
I confirm that I will not publish the program online or share it with anyone without permission of the module leader.

Student Name: Shrawan Sreekumar
Student ID : 201398821
Email: el20ss@leeds.ac.uk
Date Work Commenced: 2nd February 2021
*************************************************************************/

#include "library_management.h"

struct Book library[library_size]; //array of  books in library
int numBooks = 0;
char *output;

//***********************************************************************

struct BookArray find_book_by_title (const char *title){

    //finds books with a given title.
    //returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
    //provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
    //array is the null pointer.
    struct BookArray returnArray; 
    returnArray.array[loan_size];
    returnArray.array = (struct Book*)malloc(sizeof(struct Book*)*loan_size);
    returnArray.length = 0; //set to 0

    if(title == NULL) return returnArray; //check if input empty
    else if( isdigit(*title ) != 0) return returnArray;
    else{
        //find book using title
        for(int i=0; i<numBooks; i++){
            if(strstr(library[i].title,title) != NULL){
                returnArray.array[returnArray.length] = library[i];
                returnArray.length++;
            }
        }

        return returnArray;
    }
}


struct BookArray find_book_by_author (const char *author){

    //finds books with a given author.
    //returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
    //provided author can be found. The length of the array is also recorded in the returned structure, with 0 in case
    //array is the null pointer.

    struct BookArray returnArray; 
    returnArray.array[loan_size];
    returnArray.array = (struct Book*)malloc(sizeof(struct Book*)*loan_size);
    returnArray.length = 0; //set to 0

    if(author == NULL) return returnArray;
    else if( isdigit(*author ) != 0) return returnArray;
    else{
        //find book using author
        for(int i=0; i<numBooks; i++){
            if(strstr(library[i].authors,author) != NULL){
                returnArray.array[returnArray.length] = library[i];
                returnArray.length++;
            }
        }

        return returnArray;
    }
}


struct BookArray find_book_by_year (unsigned int year){

    //finds books published in the given year.
    //returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
    //provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
    //array is the null pointer.

    struct BookArray returnArray; 
    returnArray.array[loan_size];
    returnArray.array = (struct Book*)malloc(sizeof(struct Book*)*loan_size);
    returnArray.length = 0; //set to 0

    if(year < 0) return returnArray; //check if input empty
    else if( isdigit(year) == 0 ) return returnArray;
    else{
        //find book using year
        for(int i=0; i<numBooks; i++){
            if(library[i].year == year){
                returnArray.array[returnArray.length] = library[i];
                returnArray.length++;
            }
        }

        return returnArray;
    }

}
 

int store_books(FILE *file){

    //saves the database of books in the specified file
    //returns 0 if books were stored correctly, or an error code otherwise
    if(file == NULL) return -1;
    else{
        static char tmpauthor[MAX_STRING];
        static char tmptitle[MAX_STRING];

        fprintf(file,"%d\n",numBooks);
        for(int i=0; i<numBooks; i++){
            strcpy(tmpauthor,library[i].authors);
            strcpy(tmptitle,library[i].title);

               fprintf(file,"%d\t%s\n%s\n%d\t%d\n",
                            library[i].ID, tmpauthor, tmptitle , library[i].year, library[i].copies);

        }
        fclose(file);
        return 0;
    }
}


int load_books(FILE *file){ 

    //loads the database of books from the specified file
    //the file must have been generated by a previous call to store_books()
    //returns 0 if books were loaded correctly, or an error code otherwise
    if(file == NULL) return -1;
    else{

        fscanf(file,"%d\n",&numBooks); 
        static char tmpAut[MAX_STRING];
        static char tmpTitle[MAX_STRING];

        for(int i=0; i<numBooks; i++){

            fscanf(file,"%d\t",&library[i].ID);
            fgets(tmpAut,MAX_STRING,file);
            fgets(tmpTitle,MAX_STRING,file);
            fscanf(file,"%d\t",&library[i].year);
            fscanf(file,"%d\n",&library[i].copies);

            tmpAut[strcspn(tmpAut,"\n")] = 0;
            tmpTitle[strcspn(tmpTitle,"\n")] = 0;

            strcpy( library[i].authors,tmpAut);
            strcpy(library[i].title,tmpTitle);

             //dont forget to free the *library array
        }
        fclose(file);
        return 0;
    }
}


int add_book(struct Book book){

    //adds a book to the ones available to the library
    //returns 0 if the book could be added, or an error code otherwise
    if(book.authors == NULL) return -1;
    else if(book.title == NULL) return -1;
    else{

        for(int i = 0; i<numBooks; i++){
            if( strcmp(library[i].authors, book.authors) == 0){
                if( strcmp(library[i].title, book.title) == 0){
                    if( library[i].year == book.year){
                        library[i].copies = library[i].copies + book.copies;
                        printf("\nSuccessfully added copies \n");
                        return 0;
                    }
                }
            }
        }
        
        library[numBooks].ID = library[numBooks-1].ID + 1;
        library[numBooks].authors = book.authors;
        library[numBooks].title = book.title;
        library[numBooks].year = book.year;
        library[numBooks].copies = book.copies;

        numBooks++; 
        printf("\nSuccessfully added book \n");
        return 0;
    }

}


int remove_book(struct Book book){

    //removes a book from the library
    //returns 0 if the book could be successfully removed, or an error code otherwise.
    if(book.authors == NULL)return -1;
    else if(book.title == NULL) return -1;
    else{
        for(int i =0; i<numBooks; i++){
            if( strcmp(library[i].authors, book.authors) == 0 ){
                if( strcmp(library[i].title, book.title ) == 0 ){
                    for(int j = i; j<numBooks; j++){
                        library[j] = library[j + 1];
                    }
                    numBooks--;
                    printf("\nSuccessfully removed book\n");
                    return 0;
                }
            }
        }

        printf("\nSorry! Could not remove book.\n");
        return -1;
    }

}

const struct Book create_book(){
    //creates a new Book to be added to the library
    
    struct Book newBook;

    newBook.authors = returnString("Enter Author : ");
    free(output);
    newBook.title = returnString("Enter Title : ");
    free(output);
    printf("\nEnter Year : ");
    scanf("%d",&newBook.year);

    printf("Enter Copies : ");
    scanf("%d",&newBook.copies);

    return newBook;
}


int display_all_book(){
    //function to display all books
    printf("|%-3s|-|%-25s|-|%-25s|-|%-3s|-|%-3s| \n","ID","Author","Title","Year","Copies");
    for(int i=0; i<numBooks; i++){
        printf("|%-3d| |%-25s| |%-25s| |%-3d| |%-3d| \n",
            library[i].ID, library[i].authors, library[i].title, library[i].year, library[i].copies);
    }
}
